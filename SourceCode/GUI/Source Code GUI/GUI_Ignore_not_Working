# Example of creating a GUI frame using Tkinter
import tkinter as tk
from tkinter import filedialog, ttk, messagebox
from PIL import Image, ImageTk, ImageFilter
import csv
import subprocess
import os

class CustomGUI:
    def __init__(self, image_path):
        self.root = tk.Tk()
        self.root.title("Hashcat GUI")
        
        # Configure style for modern look
        self.style = ttk.Style()
        self.style.configure('Modern.TButton',
            padding=10,
            font=('Segoe UI', 10),
            background='#2196F3',
            foreground='white'
        )
        
        # Modern color scheme
        self.colors = {
            'primary': '#2196F3',    # Blue
            'secondary': '#1976D2',   # Darker Blue
            'accent': '#4CAF50',      # Green
            'background': '#F5F5F5',  # Light Gray
            'text': '#212121',        # Dark Gray
            'white': '#FFFFFF'
        }
        
        # Set fixed size and prevent resizing
        self.root.geometry("800x600")
        self.root.resizable(False, False)
        
        # Configure root background
        self.root.configure(bg='black')  # Set root background to black
        
        # Configure ttk styles for comboboxes
        self.style.configure('Modern.TCombobox',
            padding=5,
            relief='flat',
            background=self.colors['primary']
        )
        
        # Configure style for the slider
        self.style.configure('Modern.Horizontal.TScale',
            background=self.colors['background'],
            troughcolor=self.colors['primary'],
            sliderwidth=15,
            sliderlength=20
        )
        
        # Load the background image
        self.background_image = Image.open(image_path)
        self.background_photo = None
        
        # Create a frame that fills the window completely without padding
        self.frame = tk.Frame(self.root, bg='black')  # Set frame background to black
        self.frame.pack(expand=True, fill=tk.BOTH, padx=0, pady=0)  # Remove padding
        
        # Create a label for the background image that fills the frame
        self.background_label = tk.Label(self.frame)
        self.background_label.place(x=0, y=0, relwidth=1, relheight=1)  # Fill entire frame
        
        # Load hash types from CSV
        self.hash_types = self.load_hash_types(r"SourceCode\GUI\Source Code GUI\Hash_Types\hash_types.csv")
        
        # Call the methods to create the hash file and dictionary file selection UI
        self.create_hash_file_selection()
        self.create_hash_type_selection()
        self.create_dict_file_selection()
        self.create_output_file_selection()  # Output file selection
        self.create_workload_profile_selection()  # Workload profile selection
        self.create_temperature_selection()  # Temperature selection
        
        # Add the Execute button at the end
        self.create_execute_button()

        # Initial display
        self.show_blurred_background()

        # Update the background image to fit the window
        self.update_background_image()

        # Bind the resize event to update the background image
        self.root.bind("<Configure>", self.update_background_image)

        # Add consistent button style
        self.button_style = {
            'font': ('Segoe UI', 11),
            'bg': self.colors['primary'],  # Blue for regular buttons
            'fg': self.colors['white'],
            'activebackground': self.colors['secondary'],
            'activeforeground': self.colors['white'],
            'relief': 'flat',
            'pady': 5,
            'padx': 15,
            'cursor': 'hand2'
        }
        
        self.green_button_style = {
            'font': ('Segoe UI', 11),
            'bg': self.colors['accent'],  # Green for special actions
            'fg': self.colors['white'],
            'activebackground': '#388E3C',
            'activeforeground': self.colors['white'],
            'relief': 'flat',
            'pady': 5,
            'padx': 15,
            'cursor': 'hand2'
        }

    def load_hash_types(self, file_path):
        hash_types = {}
        with open(file_path, mode='r', newline='', encoding='utf-8') as file:
            reader = csv.reader(file)
            next(reader)  # Skip header
            for row in reader:
                if len(row) == 2 and row[1].strip():
                    hash_types[row[0]] = int(row[1])
        return hash_types

    def create_hash_file_selection(self):
        # Modern styling for labels and entries
        label_style = {
            'bg': self.colors['background'],
            'fg': self.colors['text'],
            'font': ('Segoe UI', 11),
            'pady': 5
        }
        
        entry_style = {
            'font': ('Segoe UI', 11),
            'relief': 'flat',
            'bd': 1,
            'highlightthickness': 1,
            'highlightcolor': self.colors['primary'],
            'highlightbackground': '#E0E0E0'
        }
        
        self.hash_file_label = tk.Label(self.frame, text="Select the Hash File:", **label_style)
        self.hash_file_label.grid(row=0, column=0, padx=10, pady=10, sticky="w")
        
        self.hash_file_entry = tk.Entry(self.frame, width=50, **entry_style)
        self.hash_file_entry.grid(row=0, column=1, padx=10, pady=10, sticky="ew")
        
        self.browse_hash_button = tk.Button(
            self.frame,
            text="Browse",
            command=self.browse_hash_file,
            **self.button_style
        )
        self.browse_hash_button.grid(row=0, column=2, padx=10, pady=10, sticky="ew")
        
        # Add hover effect
        self.browse_hash_button.bind('<Enter>', 
            lambda e: self.browse_hash_button.configure(bg=self.colors['secondary']))
        self.browse_hash_button.bind('<Leave>', 
            lambda e: self.browse_hash_button.configure(bg=self.colors['primary']))

    def create_hash_type_selection(self):
        label_style = {
            'bg': self.colors['background'],
            'fg': self.colors['text'],
            'font': ('Segoe UI', 11),
            'pady': 5
        }
        
        self.hash_type_label = tk.Label(self.frame, text="Select Hash Type:", **label_style)
        self.hash_type_label.grid(row=1, column=0, padx=10, pady=10, sticky="w")
        
        self.hash_type_combobox = ttk.Combobox(
            self.frame,
            values=list(self.hash_types.keys()),
            state="readonly",
            width=50,
            style='Modern.TCombobox',
            font=('Segoe UI', 10)
        )
        self.hash_type_combobox.grid(row=1, column=1, padx=10, pady=10, sticky="ew")
        
        if self.hash_types:
            self.hash_type_combobox.current(0)

    def get_hash_file(self):
        hash_file = self.hash_file_entry.get()
        if not hash_file or not os.path.isfile(hash_file):
            messagebox.showerror("Error", "Invalid or empty hash file path.")
            return None
        return hash_file

    def get_hash_type_number(self):
        selected_hash_type = self.hash_type_combobox.get()
        if selected_hash_type in self.hash_types:
            hash_number = self.hash_types[selected_hash_type]
            print(f"Selected Hash Type: {selected_hash_type}, Corresponding Number: {hash_number}")
            return hash_number
        else:
            print("Selected hash type not found.")
            return None

    def create_dict_file_selection(self):
        label_style = {
            'bg': self.colors['background'],
            'fg': self.colors['text'],
            'font': ('Segoe UI', 11),
            'pady': 5
        }
        
        entry_style = {
            'font': ('Segoe UI', 11),
            'relief': 'flat',
            'bd': 1,
            'highlightthickness': 1,
            'highlightcolor': self.colors['primary'],
            'highlightbackground': '#E0E0E0'
        }
        
        self.dict_file_entries = []
        for i in range(3):
            dict_file_label = tk.Label(
                self.frame,
                text=f"Select Dictionary File {i + 1}:",
                **label_style
            )
            dict_file_label.grid(row=i + 2, column=0, padx=10, pady=10, sticky="w")
            
            dict_file_entry = tk.Entry(self.frame, width=50, **entry_style)
            dict_file_entry.grid(row=i + 2, column=1, padx=10, pady=10, sticky="ew")
            self.dict_file_entries.append(dict_file_entry)
            
            browse_button = tk.Button(
                self.frame,
                text="Browse",
                command=lambda entry=dict_file_entry: self.browse_dict_file(entry),
                **self.button_style
            )
            browse_button.grid(row=i + 2, column=2, padx=10, pady=10, sticky="ew")
            
            # Add hover effects
            browse_button.bind('<Enter>', 
                lambda e, btn=browse_button: btn.configure(bg=self.colors['secondary']))
            browse_button.bind('<Leave>', 
                lambda e, btn=browse_button: btn.configure(bg=self.colors['primary']))

    def browse_hash_file(self):
        file_path = filedialog.askopenfilename(title="Select Hash File", filetypes=(("Text Files", "*.txt"), ("All Files", "*.*")))
        if file_path:
            self.hash_file_entry.delete(0, tk.END)
            self.hash_file_entry.insert(0, file_path)

    def browse_dict_file(self, entry):
        file_path = filedialog.askopenfilename(title="Select Dictionary File", filetypes=(("Text Files", "*.txt"), ("All Files", "*.*")))
        if file_path:
            entry.delete(0, tk.END)
            entry.insert(0, file_path)

    def create_output_file_selection(self):
        label_style = {
            'bg': self.colors['background'],
            'fg': self.colors['text'],
            'font': ('Segoe UI', 11),
            'pady': 5
        }
        
        entry_style = {
            'font': ('Segoe UI', 11),
            'relief': 'flat',
            'bd': 1,
            'highlightthickness': 1,
            'highlightcolor': self.colors['primary'],
            'highlightbackground': '#E0E0E0'
        }
        
        self.output_file_label = tk.Label(self.frame, text="Define Output File:", **label_style)
        self.output_file_label.grid(row=5, column=0, padx=10, pady=10, sticky="w")
        
        self.output_file_entry = tk.Entry(self.frame, width=50, **entry_style)
        self.output_file_entry.grid(row=5, column=1, padx=10, pady=10, sticky="ew")
        
        self.browse_output_file_button = tk.Button(
            self.frame,
            text="Browse",
            command=self.browse_output_file,
            **self.green_button_style
        )
        self.browse_output_file_button.grid(row=5, column=2, padx=10, pady=10, sticky="ew")
        
        # Add hover effect
        self.browse_output_file_button.bind('<Enter>', 
            lambda e: self.browse_output_file_button.configure(bg='#388E3C'))
        self.browse_output_file_button.bind('<Leave>', 
            lambda e: self.browse_output_file_button.configure(bg=self.colors['accent']))

    def browse_output_file(self):
        file_path = filedialog.asksaveasfilename(title="Define Output File", defaultextension=".txt", filetypes=(("Text Files", "*.txt"), ("All Files", "*.*")))
        if file_path:
            self.output_file_entry.delete(0, tk.END)
            self.output_file_entry.insert(0, file_path)

    def get_dictionary_files(self):
        dict_file_paths = [entry.get() for entry in self.dict_file_entries]
        
        if not dict_file_paths[0]:
            messagebox.showerror("Error", "Dictionary 1 is required.")
            return None
        
        command_string = ["-a", "0", dict_file_paths[0]]
        if dict_file_paths[1]:
            command_string.append(dict_file_paths[1])
        if dict_file_paths[2]:
            command_string.append(dict_file_paths[2])
        
        return command_string

    def get_output_file(self):
        output_file = self.output_file_entry.get()
        if not output_file:
            messagebox.showerror("Error", "Output file must be defined.")
            return None
        return output_file

    def create_workload_profile_selection(self):
        label_style = {
            'bg': self.colors['background'],
            'fg': self.colors['text'],
            'font': ('Segoe UI', 11),
            'pady': 5
        }
        
        # Configure combobox style
        self.style.configure('Workload.TCombobox',
            background=self.colors['primary'],
            fieldbackground='white',
            selectbackground=self.colors['primary'],
            selectforeground='white',
            padding=5
        )
        
        self.workload_profile_label = tk.Label(
            self.frame,
            text="Select Workload Profile:",
            **label_style
        )
        self.workload_profile_label.grid(row=6, column=0, padx=10, pady=10, sticky="w")
        
        self.workload_profile_combobox = ttk.Combobox(
            self.frame,
            values=["1 - Low", "2 - Default", "3 - High", "4 - Nightmare"],
            state="readonly",
            width=50,
            style='Workload.TCombobox',
            font=('Segoe UI', 10)
        )
        self.workload_profile_combobox.grid(row=6, column=1, padx=10, pady=10, sticky="ew")
        self.workload_profile_combobox.current(1)

    def get_workload_profile(self):
        selected_profile = self.workload_profile_combobox.get()
        if selected_profile:
            return selected_profile.split(" ")[0]  # Return the numeric part (e.g., "1", "2", "3", "4")
        return None

    def create_temperature_selection(self):
        label_style = {
            'bg': self.colors['background'],
            'fg': self.colors['text'],
            'font': ('Segoe UI', 11),
            'pady': 5
        }
        
        frame_style = {
            'bg': self.colors['background'],
            'highlightthickness': 0,
            'bd': 0
        }
        
        temp_frame = tk.Frame(self.frame, **frame_style)
        temp_frame.grid(row=7, column=0, columnspan=3, padx=10, pady=10, sticky="ew")
        
        self.temp_label = tk.Label(
            temp_frame,
            text="Select Abort Temperature (°C):",
            **label_style
        )
        self.temp_label.pack(side=tk.LEFT, padx=(0, 10))
        
        self.temp_slider = ttk.Scale(
            temp_frame,
            from_=80,
            to=100,
            orient=tk.HORIZONTAL,
            style='Temp.Horizontal.TScale',
            command=lambda v: self.update_temp_label(int(float(v))),  # Convert to int
        )
        self.temp_slider.set(100)
        self.temp_slider.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=10)
        
        self.temp_value_label = tk.Label(
            temp_frame,
            text="100 °C",
            font=('Segoe UI', 11),
            bg=self.colors['background'],
            fg=self.colors['primary']
        )
        self.temp_value_label.pack(side=tk.LEFT, padx=(10, 0))

    def update_temp_label(self, value):
        """Update temperature label with integer values only"""
        self.temp_value_label.config(text=f"{int(value)} °C")

    def get_abort_temperature(self):
        """Return integer temperature value"""
        return int(self.temp_slider.get())

    def show_blurred_background(self):
        # Initial background setup with exact dimensions
        width = 800
        height = 600
        resized_image = self.background_image.resize((width, height), Image.LANCZOS)
        blurred_image = resized_image.filter(ImageFilter.GaussianBlur(radius=15))
        darkened_image = Image.new('RGBA', blurred_image.size, (0, 0, 0, 130))
        blurred_image = Image.alpha_composite(blurred_image.convert('RGBA'), darkened_image)
        self.background_photo = ImageTk.PhotoImage(blurred_image)
        self.background_label.config(image=self.background_photo)

    def update_background_image(self, event=None):
        """Update the background image to fit the window size."""
        width = 800
        height = 600
        
        # Resize the original image to fit the window exactly
        resized_image = self.background_image.resize((width, height), Image.LANCZOS)
        
        # Apply blur and overlay effect
        blurred_image = resized_image.filter(ImageFilter.GaussianBlur(radius=15))
        darkened_image = Image.new('RGBA', blurred_image.size, (0, 0, 0, 130))
        blurred_image = Image.alpha_composite(blurred_image.convert('RGBA'), darkened_image)
        
        self.background_photo = ImageTk.PhotoImage(blurred_image)
        self.background_label.config(image=self.background_photo)

    def create_execute_button(self):
        execute_button = tk.Button(
            self.frame,
            text="Execute",
            command=self.run_hashcat,
            font=('Segoe UI', 12, 'bold'),  # Slightly larger font for execute button
            **self.green_button_style
        )
        execute_button.grid(row=8, column=1, padx=10, pady=20, sticky="nsew")
        
        # Add hover effect
        execute_button.bind('<Enter>', lambda e: execute_button.configure(bg='#388E3C'))
        execute_button.bind('<Leave>', lambda e: execute_button.configure(bg=self.colors['accent']))

    def run_hashcat(self):
        """Run the Hashcat software with the selected options."""
        hash_file = self.get_hash_file()  # Get the hash file path and validate it
        if hash_file is None:
            return  # Exit if the hash file is invalid

        selected_hash_type = self.get_hash_type_number()  # Call the function to get the hash type number
        if selected_hash_type is None:
            return  # Exit if the hash type is not valid

        dict_args = self.get_dictionary_files()  # Get dictionary file paths as a formatted string
        if dict_args is None:
            return  # Exit if Dictionary 1 is not provided

        output_file = self.get_output_file()  # Get the output file path
        if output_file is None:
            return  # Exit if the output file is not defined

        workload_profile = self.get_workload_profile()  # Get the selected workload profile
        if workload_profile is None:
            return  # Exit if the workload profile is not defined

        abort_temp = self.get_abort_temperature()  # Get the selected abort temperature

        # Construct the command as a flat list
        command = [
            "SourceCode\\hashcat-6.2.6\\hashcat.exe",
            "-m", str(selected_hash_type),
            hash_file,
            "-w", workload_profile,  # Add workload profile option
            "-O",  # Add the -O option Enable optimized kernels (limits password length)
            f"--hwmon-temp-abort={abort_temp}"  # Add the abort temperature option
        ] + dict_args + ["-o", output_file]  # Add output file option

        print("Command to execute:", command)

        try:
            # Open Hashcat in a new console window without capturing output
            subprocess.Popen(
                command,
                cwd="SourceCode\\hashcat-6.2.6",
                creationflags=subprocess.CREATE_NEW_CONSOLE  # Open in a new console window
            )
        except Exception as e:
            print(f"Failed to execute Hashcat: {e}")

    def run(self):
        self.root.mainloop()

# Create an instance of the CustomGUI class and run it
gui = CustomGUI(r"SourceCode\GUI\Images\Background-image.jpg")
gui.run()
